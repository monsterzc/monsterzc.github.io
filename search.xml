<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工厂设计模式</title>
      <link href="/post/a24d988e.html"/>
      <url>/post/a24d988e.html</url>
      
        <content type="html"><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>模式定义</strong>：定义一个用于创建对象的接口，让子类决定实例话哪一个类。Factory Method使得一个类的实例化延迟到之类</p><p><img src="/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230413011148293.png" alt="image-20230413011148293"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Application</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> application.getObject();</span><br><span class="line">        product.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前路漫漫亦灿灿😁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">    Product <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> createProduct();</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> <span class="keyword">extends</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> <span class="keyword">extends</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：</p><p>1.当你不知道该使用对象的确切类型的时候</p><p>2.当你希望为库或框架提供扩展其内部组件的方法时</p><p><strong>主要优点</strong>：</p><p>1.将具体产品和创建者耦合</p><p>2.符合单一职责原则</p><p>3.符合开闭原则</p><p><strong>源码中的应用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java api</span></span><br><span class="line">Calendar.getInstance()</span><br><span class="line">java.text.NumberFormat.getInstance()</span><br><span class="line">java.util.ResourceBundle.getBundle()</span><br><span class="line"><span class="comment">// 工厂方法</span></span><br><span class="line">java.net.URLStreamHandlerFactory</span><br><span class="line">javax.xml.bind.JAXBContext#createMarshaller</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/post/cd333c07.html"/>
      <url>/post/cd333c07.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、单例模式的定义及使用场景"><a href="#一、单例模式的定义及使用场景" class="headerlink" title="一、单例模式的定义及使用场景"></a>一、单例模式的定义及使用场景</h2><p><strong>模式定义</strong>：保证一个类只有一个实例，并且提供一个全局访问点。</p><p><strong>场景</strong>：重量级的对象，不需要多个实例，如线程池，数据库连接池。</p><h2 id="二、单例模式的实现方式"><a href="#二、单例模式的实现方式" class="headerlink" title="二、单例模式的实现方式"></a>二、单例模式的实现方式</h2><h3 id="1-懒汉模式：延迟加载，只有在真正使用的时候，才开始实例化。"><a href="#1-懒汉模式：延迟加载，只有在真正使用的时候，才开始实例化。" class="headerlink" title="1.懒汉模式：延迟加载，只有在真正使用的时候，才开始实例化。"></a>1.懒汉模式：延迟加载，只有在真正使用的时候，才开始实例化。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton lazySingleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == lazySingleton)&#123;</span><br><span class="line">                <span class="comment">// double check</span></span><br><span class="line">                <span class="keyword">synchronized</span> (LazySingleton.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == lazySingleton)&#123;</span><br><span class="line">                        <span class="comment">// 字节码层</span></span><br><span class="line">                        <span class="comment">// JIT，CPU</span></span><br><span class="line">                        <span class="comment">// 1.分配空间</span></span><br><span class="line">                        <span class="comment">// 2.引用赋值</span></span><br><span class="line">                        <span class="comment">// 3.初始化</span></span><br><span class="line">                        lazySingleton = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）线程安全问题</p><p>2）double check，枷锁优化</p><p>3）编译器(JIT),CPU有可能对指令进行重排序，导致使用到未初始化的实例，可以通过添加volatile关键字进行修饰，对于volatile修饰的字段，可以防止指令重拍。</p><h3 id="2-饿汉模式：类加载的初始化阶段就完成了实例的初始化，本质上就是借助于jvm类加载机制，保证实例的唯一性。"><a href="#2-饿汉模式：类加载的初始化阶段就完成了实例的初始化，本质上就是借助于jvm类加载机制，保证实例的唯一性。" class="headerlink" title="2.饿汉模式：类加载的初始化阶段就完成了实例的初始化，本质上就是借助于jvm类加载机制，保证实例的唯一性。"></a>2.饿汉模式：类加载的初始化阶段就完成了实例的初始化，本质上就是借助于jvm类加载机制，保证实例的唯一性。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HungrySingleton</span> <span class="variable">hungrySingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (HungrySingleton.getInstance()!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例模式不允许多个实例存在！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载过程：</p><p>1）加载二进制数据到内存中，生成对应的Class数据结构</p><p>2）连接：a.验证，b.准备（给类的静态成员变量赋默认值），c.解析</p><p>3）初始化：给类的静态变量赋值</p><p>只有在真正使用对应的类时，才会触发初始化（当前类时启动类即main函数所在类，直接new操作，访问静态属性，访问静态方法，用反射访问类，初始化一个类的子类等）。</p><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InnerClassSingleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClassHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">InnerClassSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">InnerClassSingleton</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (InnerClassHolder.instance!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例模式不允许多个实例存在！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClassHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）本质上是利用类的加载机制来保证线程安全</p><p>2）只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一种形式。</p><h3 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4.枚举类型"></a>4.枚举类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(INSTANCE.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）天然不支持反射创建的实例，且有自己的反序列化机制</p><p>2）利用类加载自己保证线程安全</p><h3 id="5-反射攻击实例"><a href="#5-反射攻击实例" class="headerlink" title="5.反射攻击实例"></a>5.反射攻击实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;InnerClassSingleton&gt; declaredConstructor = InnerClassSingleton.class.getDeclaredConstructor();</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InnerClassSingleton</span> <span class="variable">innerClassSingleton</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        <span class="type">InnerClassSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> InnerClassSingleton.getInstance();</span><br><span class="line">        System.out.println(innerClassSingleton==instance);</span><br></pre></td></tr></table></figure><h3 id="6-序列化"><a href="#6-序列化" class="headerlink" title="6.序列化"></a>6.序列化</h3><p><strong>对象需要实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InnerClassSingleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1324250553112887638L</span>;</span><br><span class="line">  </span><br><span class="line">    Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClassHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）可以利用指定方法来替换从反序列化流中的数据 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY-ACCESS-MODIFIER Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException;</span><br></pre></td></tr></table></figure><p><strong>Spring源码应用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring &amp;&amp; JDK</span></span><br><span class="line">java.lang.Runtime</span><br><span class="line">org.springframework.aop.framework.ProxyFactoryBean</span><br><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span><br><span class="line">org.springframework.core.ReactiveAdapterRegistry</span><br><span class="line"><span class="comment">// Tomcat</span></span><br><span class="line">org.apache.catalina.webresources.TomcatURLStreamHandlerFactory</span><br><span class="line"><span class="comment">// 反序列化指定数据源</span></span><br><span class="line">java.util.Currency</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题整理</title>
      <link href="/post/d6058b93.html"/>
      <url>/post/d6058b93.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-redis为什么是单线程？"><a href="#1-redis为什么是单线程？" class="headerlink" title="1.redis为什么是单线程？"></a>1.redis为什么是单线程？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis是单线程的原因在于redis用单个CPU绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的。redis核心就是，如果我的数据全都在内存里，我单线程的去操作就是效率最高的。所以，redis是单线程。</span><br><span class="line">官方答案：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</span><br></pre></td></tr></table></figure><h2 id="2-深拷贝和浅拷贝的区别？以及深拷贝最简单的实现方式？"><a href="#2-深拷贝和浅拷贝的区别？以及深拷贝最简单的实现方式？" class="headerlink" title="2.深拷贝和浅拷贝的区别？以及深拷贝最简单的实现方式？"></a>2.深拷贝和浅拷贝的区别？以及深拷贝最简单的实现方式？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用</span><br><span class="line">深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”</span><br><span class="line">第一种实现方式是重写clone方法来实现深拷贝(实现cloneable接口)</span><br><span class="line">第二种通过对象序列化实现深拷贝(实现Serializable接口)</span><br></pre></td></tr></table></figure><h2 id="3-beanFactory和ApplicationContext的区别？"><a href="#3-beanFactory和ApplicationContext的区别？" class="headerlink" title="3.beanFactory和ApplicationContext的区别？"></a>3.beanFactory和ApplicationContext的区别？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</span><br><span class="line">BeanFactory:BeanFactory是Spring里面最底层的接口,是Ioc的核心,定义了Ioc的基本功能,包含了各种Bean的定义、加载、实例化,依赖注入和生命周期管理;</span><br><span class="line">ApplicationContext:ApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:</span><br><span class="line">①继承MessageSource,因此支持国际化</span><br><span class="line">②资源文件访问，如URL和文件（ResourceLoader）</span><br><span class="line">③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次</span><br><span class="line">④提供在监听器中注册bean的事件；</span><br></pre></td></tr></table></figure><h2 id="4-并发编程。乐观锁和悲观锁。"><a href="#4-并发编程。乐观锁和悲观锁。" class="headerlink" title="4.并发编程。乐观锁和悲观锁。"></a>4.并发编程。乐观锁和悲观锁。</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">乐观锁：指的是在操作数据的时候非常乐观，乐观地认为别人不会同时修改数据，因此乐观锁默认是不会上锁的，只有在执行更新的时候才会去判断在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。</span><br><span class="line">指的是在操作数据的时候比较悲观，悲观地认为别人一定会同时修改数据，因此悲观锁在操作数据时是直接把数据上锁，直到操作完成之后才会释放锁，在上锁期间其他人不能操作数据。</span><br></pre></td></tr></table></figure><h2 id="5-线程池创建方式有几种？"><a href="#5-线程池创建方式有几种？" class="headerlink" title="5.线程池创建方式有几种？"></a>5.线程池创建方式有几种？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线程池的创建方式总共包含以下 7 种（其中 6 种是通过 Executors 创建的，1 种是通过 ThreadPoolExecutor 创建的）：</span><br><span class="line">Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；</span><br><span class="line">Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；</span><br><span class="line">Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序；</span><br><span class="line">Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池；</span><br><span class="line">Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池；</span><br><span class="line">Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</span><br><span class="line">ThreadPoolExecutor：最原始的创建线程池的方式，它包含了 7 个参数可供设置，后面会详细讲。</span><br></pre></td></tr></table></figure><h2 id="6-类的加载过程"><a href="#6-类的加载过程" class="headerlink" title="6.类的加载过程"></a>6.类的加载过程</h2><p><img src="/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/image-20230306144451940.png" alt="image-20230306144451940"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">读取加载class文件---&gt;链接过程[验证、准备、解析]---&gt;初始化</span><br><span class="line">通过双亲委派模型实现（倚父）</span><br><span class="line">打破双亲委派模型？</span><br><span class="line">1）自定义类加载器，重写loadclass</span><br><span class="line">2）spi机制绕开loadclass方法，当前线程设定关联加载器。spi机制：加载第三方扩展的jar包类初始化</span><br><span class="line">本地磁盘文件Java代码变为的class文件</span><br><span class="line">通过网络下载的class文件</span><br><span class="line">war、jar解压的class文件</span><br><span class="line">从专门的数据库中读取的class文件</span><br><span class="line">使用Java cglib、动态代理生成的代理类class文件</span><br></pre></td></tr></table></figure><h2 id="7-包装类和普通类的区别？"><a href="#7-包装类和普通类的区别？" class="headerlink" title="7.包装类和普通类的区别？"></a>7.包装类和普通类的区别？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">普通类有默认值，包装类没有默认值，初始值是null.</span><br><span class="line">普通类在局部变量表里面，包装类在堆里</span><br><span class="line">普通类型可以直接定义，包装类需要new关键字</span><br></pre></td></tr></table></figure><h2 id="8-事务的传播机制类型"><a href="#8-事务的传播机制类型" class="headerlink" title="8.事务的传播机制类型"></a>8.事务的传播机制类型</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过transactionDefinition类中定义了事务传播的七种类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line"><span class="comment">// 如果当前存在事务，那么就加入这个事务，不存在就新建一个事务。</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果当前有事务，加入事务，如果没有则不使用事务</span></span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必须在一个事务中执行，如果没有事务，则抛出异常</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不管是否存在事务，都以最新的事务执行，执行完在执行旧的事务</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示不支持事务，如果有事务也不加入事</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以非事务的方式执行，如果存在事务异常</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果调用者不存在事务，那么被调用者自己创建事务，这种情况和REQUIRE一样。</span></span><br><span class="line">  <span class="comment">// 如果调用者存在事务，那么被调用者就在调用者的事务里嵌套一个事务，称为嵌套事务。</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-AOP有几种通知类型？执行顺序是什么样的？"><a href="#9-AOP有几种通知类型？执行顺序是什么样的？" class="headerlink" title="9.AOP有几种通知类型？执行顺序是什么样的？"></a>9.AOP有几种通知类型？执行顺序是什么样的？</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aop：1.定义切点 2.定义切面逻辑 3.织入</span><br><span class="line">有五种通知类型？</span><br><span class="line">1.前置通知（@Before）:设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before advice ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.后置通知（@After）：设置当前通知方法与切入点之前的绑定关系，当前通知方法在原始切入点方法后运行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.抛出异常后的通知（@AfterThrowing）:设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.返回后的通知（@AfterReturning）:设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法正常执行完毕后运行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.环绕通知（@Around）：设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;around advice ...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行顺序：</span><br><span class="line">@Around 前部分业务逻辑</span><br><span class="line">@Before业务逻辑</span><br><span class="line">@AfterReturning业务逻辑</span><br><span class="line">@AfterThrowing业务逻辑</span><br><span class="line">@After业务逻辑</span><br><span class="line">@Around后部分业务逻辑</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/post/d0edc1ed.html"/>
      <url>/post/d0edc1ed.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pwd:</span> <span class="string">显示用户所在的目录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ls:</span> <span class="string">对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息</span></span><br><span class="line"><span class="string">格式:</span> <span class="string">ls</span> [<span class="string">选项</span>][<span class="string">目录或文件</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">查看当前目录下的文件，包括隐藏文件</td></tr><tr><td align="center">-l</td><td align="center">长格式显示文件</td></tr><tr><td align="center">-lh</td><td align="center">以方便阅读的长格式显示</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cd:</span> <span class="string">改变工作目录。将工作目录改变到指定的目录下。</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">cd</span>  <span class="string">目录名</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">cd ..</td><td align="center">返回上一级目录</td></tr><tr><td align="center">cd ..&#x2F;..</td><td align="center">返回上两级目录</td></tr><tr><td align="center">cd ~</td><td align="center">切换到home目录</td></tr><tr><td align="center">cd &#x2F;</td><td align="center">切换到根目录</td></tr><tr><td align="center">cd &#x2F;home&#x2F;lx&#x2F;linux1&#x2F;</td><td align="center">绝对路径：从home目录出发，直到去想要的目录</td></tr><tr><td align="center">cd …&#x2F;lx&#x2F;</td><td align="center">相对路径：从当前目录出发，直到去想要的目录</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">grep:</span> <span class="string">用于查找文件里符合条件的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">grep</span> [<span class="string">选项</span>] <span class="string">‘查找字符串’</span> <span class="string">文件名</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">将binary文件以text文件的方式查找数据</td></tr><tr><td align="center">-c</td><td align="center">计算找到‘查找字符串’的次数</td></tr><tr><td align="center">-i</td><td align="center">忽略大小写的区别，即把大小写视为相同</td></tr><tr><td align="center">-v</td><td align="center">反向选择，即显示出没有‘查找字符串’内容的那一行</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">find:</span> <span class="string">用来在指定目录下查找文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">find</span> [<span class="string">路径</span>] [<span class="string">选项</span>] <span class="string">操作</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-name test</td><td>查询指定目录下，命明为test的文件</td></tr><tr><td>-size + 100k</td><td>查询指定目录下，文件大于100k的文件</td></tr><tr><td>-ctime n</td><td>查询指定目录下，在过去n天内被修改过的文件</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">chmod:</span> <span class="string">控制用户对文件的权限的命令</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-r</td><td align="center">赋予读取权限</td></tr><tr><td align="center">-w</td><td align="center">赋予写入权限</td></tr><tr><td align="center">-x</td><td align="center">赋予执行权限</td></tr><tr><td align="center">777</td><td align="center">赋予可读、可写、可执行权限(读：4，写2，执行：1)</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ps:</span>  <span class="string">用来列出系统当中正在运行的那些进程，类似于Windows的任务管理器</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">ps</span> [<span class="string">选项</span>]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-A</td><td align="center">列出所有的进程(重要)</td></tr><tr><td align="center">-ef</td><td align="center">查看全格式的全部进程(重要)</td></tr><tr><td align="center">-w</td><td align="center">显示加宽可以显示较多的资讯</td></tr><tr><td align="center">-au</td><td align="center">显示详细的资讯</td></tr><tr><td align="center">-aux</td><td align="center">显示所有包含其他使用这的行程</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kill:</span> <span class="string">用于删除执行中的程序或工作</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">kill</span> [<span class="string">选项</span>]<span class="string">/[信号]</span> <span class="string">进程号</span></span><br><span class="line"></span><br><span class="line"><span class="string">常用选项:</span> </span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-l</td><td align="center">参数会列出全部的信息名称</td></tr><tr><td align="center">-s</td><td align="center">指定要送出的信息</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">常用信号:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">信号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-1(HUP)</td><td align="center">重新加载一个进程</td></tr><tr><td align="center">-9(KULL)</td><td align="center">杀死一个进程(重要)</td></tr><tr><td align="center">-15(TERM)</td><td align="center">正常停止一个进程</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tail:</span> <span class="string">查看测试项目的日志</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">tail</span> [<span class="string">选项</span>] <span class="string">文件名</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">实时读取</td></tr><tr><td align="center">-1000</td><td align="center">查看最近1000行日志</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">netstat:</span> <span class="string">查看端口</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">netstat</span> <span class="string">-anp</span> <span class="string">|</span> <span class="string">grep端口号</span></span><br><span class="line"></span><br><span class="line"><span class="attr">date:</span> <span class="string">查看当前系统时间</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">date</span> <span class="string">+%[选项]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">星期几(数字几)</td></tr><tr><td align="center">A</td><td align="center">星期几(星期几)</td></tr><tr><td align="center">b</td><td align="center">月份</td></tr><tr><td align="center">B</td><td align="center">月份</td></tr><tr><td align="center">c</td><td align="center">直接显示日期与时间</td></tr><tr><td align="center">d</td><td align="center">日</td></tr><tr><td align="center">D</td><td align="center">直接显示日期</td></tr><tr><td align="center">F</td><td align="center">日期(yyyy-mm-dd)</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">echo:</span> <span class="string">打印信息</span></span><br><span class="line"></span><br><span class="line"><span class="string">格式:</span> <span class="string">echo</span> <span class="string">打印</span> <span class="string">选项</span> <span class="string">-e</span></span><br><span class="line"></span><br><span class="line"><span class="string">打印常量</span> <span class="string">直接打印</span></span><br><span class="line"><span class="string">打印变量</span> <span class="string">变量前加$</span></span><br><span class="line"><span class="string">打印命令</span> <span class="string">用反引号把命令引起来</span></span><br><span class="line"><span class="string">终端间传递信息</span> <span class="string">echo</span> <span class="string">内容&gt;/dev/pts/终端号</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top:</span> <span class="string">用于实时显示process的动态</span></span><br><span class="line"></span><br><span class="line"><span class="string">使用权限:</span> <span class="string">所有使用者</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">d</td><td align="center">改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</td></tr><tr><td align="center">q</td><td align="center">没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</td></tr><tr><td align="center">c</td><td align="center">切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称</td></tr><tr><td align="center">S</td><td align="center">累积模式，会将己完成或消失的子进程 ( dead child process ) 的 CPU time 累积起来</td></tr><tr><td align="center">s</td><td align="center">安全模式，将交谈式指令取消, 避免潜在的危机</td></tr><tr><td align="center">i</td><td align="center">不显示任何闲置 (idle) 或无用 (zombie) 的进程</td></tr><tr><td align="center">n</td><td align="center">更新的次数，完成后将会退出 top</td></tr><tr><td align="center">b</td><td align="center">批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC高并发编程一(JUC概述)</title>
      <link href="/post/4375d06b.html"/>
      <url>/post/4375d06b.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是JUC"><a href="#1-什么是JUC" class="headerlink" title="1 什么是JUC"></a>1 什么是JUC</h1><p><img src="/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80-JUC%E6%A6%82%E8%BF%B0/JUC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.png" alt="JUC高并发编程"></p><h2 id="1-1-JUC简介"><a href="#1-1-JUC简介" class="headerlink" title="1.1 JUC简介"></a>1.1 JUC简介</h2><p>JUC就是java.util.concurrent工具包的简称。这是一个处理线程的工具包,JDK 1.5开始出现。</p><h2 id="1-2-进程与线程"><a href="#1-2-进程与线程" class="headerlink" title="1.2 进程与线程"></a>1.2 进程与线程</h2><p><strong>进程</strong>（<strong>Process</strong>）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。<br><strong>线程</strong>（<strong>Thread</strong>）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p><strong>总结来说:</strong><br>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。<br>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。是程序执行的最小单位。</p><h2 id="1-3-线程的状态"><a href="#1-3-线程的状态" class="headerlink" title="1.3 线程的状态"></a>1.3 线程的状态</h2><h3 id="1-3-1-线程状态枚举类"><a href="#1-3-1-线程状态枚举类" class="headerlink" title="1.3.1 线程状态枚举类"></a>1.3.1 线程状态枚举类</h3><p><strong>Thread.State</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW(新建),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE(准备就绪),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED(阻塞),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING(等待),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING(超时),</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED(终结);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-wait-x2F-sleep的区别"><a href="#1-3-2-wait-x2F-sleep的区别" class="headerlink" title="1.3.2 wait&#x2F;sleep的区别"></a>1.3.2 wait&#x2F;sleep的区别</h3><p>（1）sleep是Thread的静态方法，wait是Object的方法，任何实例都能调用。<br>（2）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在Synchronized中)。<br>（3）他们都能被interrupt方法中断。</p><h2 id="1-4并发与串行"><a href="#1-4并发与串行" class="headerlink" title="1.4并发与串行"></a>1.4并发与串行</h2><h3 id="1-4-1-串行模式"><a href="#1-4-1-串行模式" class="headerlink" title="1.4.1 串行模式"></a>1.4.1 串行模式</h3><p>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能<br>运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步<br>骤，才能进行下一个步骤。<br><strong>串行是一次只能取得一个任务，并执行这个任务。</strong></p><h3 id="1-4-2并行模式"><a href="#1-4-2并行模式" class="headerlink" title="1.4.2并行模式"></a>1.4.2并行模式</h3><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程&#x2F;多线程代码，从硬件角度上则依赖于多核 CPU。</p><h3 id="1-4-3并发"><a href="#1-4-3并发" class="headerlink" title="1.4.3并发"></a>1.4.3并发</h3><p> <strong>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行</strong>。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，&#x3D;&#x3D;并发的重点在于它是一种现象&#x3D;&#x3D;, &#x3D;&#x3D;并发描述的是多进程同时运行的现象&#x3D;&#x3D;。但实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会。</p><p> <strong>要解决大并发问题，通常是将大任务分解成多个小任务</strong>, 由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：</p><p>​    • 可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果<br>​    • 可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务。<br>​    • 可以多进程&#x2F;多线程的方式并行执行这些小任务。也可以单进程&#x2F;单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率</p><h3 id="1-4-4小结-重点"><a href="#1-4-4小结-重点" class="headerlink" title="1.4.4小结(重点)"></a>1.4.4小结(重点)</h3><p>​    <strong>并发</strong>：同一时刻多个线程在访问同一个资源，多个线程对一个点<br>​    例子：春运抢票 电商秒杀…<br>​    <strong>并行</strong>：多项工作一起执行，之后再汇总<br>​    例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p><h2 id="1-5管程"><a href="#1-5管程" class="headerlink" title="1.5管程"></a>1.5管程</h2><p>​    管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程</p><h2 id="1-6用户线程和守护线程"><a href="#1-6用户线程和守护线程" class="headerlink" title="1.6用户线程和守护线程"></a>1.6用户线程和守护线程</h2><p>​    <strong>用户线程</strong>:平时用到的普通线程,自定义线程<br>​    <strong>守护线程</strong>:运行在后台,是一种特殊的线程,比如垃圾回收<br>​    <strong>当主线程结束后,用户线程还在运行,JVM 存活</strong><br>​    <strong>如果没有用户线程,都是守护线程,JVM 结束</strong></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
